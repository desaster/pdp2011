         .title xubw - xu esp32 wireless network adapter frontend microcode

;--
;-- Copyright (c) 2008-2023 Sytse van Slooten
;--
;-- Permission is hereby granted to any person obtaining a copy of these VHDL source files and
;-- other language source files and associated documentation files ("the materials") to use
;-- these materials solely for personal, non-commercial purposes.
;-- You are also granted permission to make changes to the materials, on the condition that this
;-- copyright notice is retained unchanged.
;--
;-- The materials are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY;
;-- without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
;--
;
;
;
lc       =.
         jmp t49
;
; some constants
;
maxpay   = 1518.
hdrlen   = 12.
;
; general purpose register definitions
;
r0       = %0
r1       = %1
r2       = %2
r3       = %3
r4       = %4
r5       = %5
r6       = %6
r7       = %7
sp       = %6
pc       = %7
;
; macros
;
         .macro xubfc
         tst @#177000
         .endm
;
         .macro xubf f,t,l
         mov f,@#177000
         mov l,@#177004
         mov t,@#177002
         .endm
;
         .macro xubm u,u18,x,l
         jsr    pc,xubm
         .word  u
         .word  u18
         .word  x
         .word  l
         .endm
;
         .macro xasciz w
         jsr    pc,xasciz
         .asciz /w/
         .even
         .endm
;
         .macro xascil w
         jsr    pc,xasciz
         .ascii /w/
         .asciz <15><12>
         .even
         .endm
;
         .macro xascnl
         jsr    pc,xasciz
         .asciz <15><12>
         .even
         .endm
;
         .macro xbhx w,l
         jsr    pc,xbhx
         .word  w
         .word  l
         .endm
;
         .macro xwhx w,l
         jsr    pc,xwhx
         .word  w
         .word  l
         .endm
;
; start of code
;
         .=lc+1000
t49:
         mov    #340,@#177776          ; set psw prio to 7 - block interrupts
         mov    #1000,sp               ; setup stack
         clr    dogtick                ; clear watchdog count
         mov    #dog,@#100             ; setup vector for watchdog
         mov    #340,@#102             ; psw for watchdog vector
         mov    #100,@#177546          ; enable clock interrupt
;
; init ourselves
;
         jsr    pc,init                ; setup variable values
         jsr    pc,waitabit            ; delay loop
         xascil <Hello, world: xu-cpu [t49] deuna esp32 microcode>
;
         clr    @#177776               ; clear psw - this enables the watchdog interrupts
;
;         mov    #400,@#174510          ; pcsr0 - usci would make sense, but 2.11bsd doesn't play well with it. dni is better.
         mov    #4000,@#174510         ; pcsr0 - dni
         mov    #2,@#174512            ; pcsr1 - state=ready
         br     10$
;
; main service loop - receive packets if we're running
;
10$:
         clr    dogtick                ; need to do this every 10 seconds, or watchdog will cause reboot

         xubfc                         ; is the esp ready for spi
         bmi    30$                    ; no, jump past everything to do with payload
         mov    #hdrlen+maxpay,r0      ; get length for spi transaction
         tst    running                ; running?
         bne    12$                    ; branch if yes
         mov    #hdrlen,r0             ; short spi transaction if not running
         tst    dbia                   ; do we have the bia already?
         bne    30$                    ; yes - then make sure we don't miss the start command
12$:
         mov    #120240,tfmgk          ; make sure magik is set
         incb   tffrq                  ; bump frame counter
         xubf   #tfbuf,#rfbuf,r0       ; do spi trx
         clr    tfpllh                 ; signal transmit buffer is available
;
         tst    rfpllh                 ; is the length nonzero?
         beq    15$                    ; branch is it is zero, skip printing
;         xasciz <esp32 rec : >
;         xbhx   rfbuf,22               ; dump buffer
;         xascil
;
15$:
         mov    #dlaa,r0               ; copy rfmac to dlaa and dbia if that's still zero
         mov    #rfmac,r1
         mov    (r1)+,(r0)+
         mov    (r1)+,(r0)+
         mov    (r1)+,(r0)+
         tst    dbia
         bne    18$
         mov    #dbia+6,r0
         mov    -(r1),-(r0)
         mov    -(r1),-(r0)
         mov    -(r1),-(r0)
18$:
         tst    running                ; in running state?
         beq    30$                    ; no - jump
;
; process packet received from the esp32
;
         cmpb   #252,rfmgk1            ; check magik1
         bne    30$                    ; not ok, skip processing
         cmpb   #125,rfmgk2            ; check magik2
         bne    30$                    ; not ok, skip processing
         tst    rfpllh                 ; is the receive length nonzero?
         beq    20$                    ; it is zero - no payload received, skip
;
         jsr    pc,pktin               ; process input packets
         clr    rfpllh
         tst    recvdw                 ; did we do any work receiving?
         beq    20$                    ; no - jump
         bis    #20000,@#174510        ; set rxi
20$:
         tst    pdmdct                 ; check poll demand counter
         beq    30$
         dec    pdmdct                 ; count this run
         jsr    pc,xmitpl              ; poll xmit ring
         tst    xmitdw
         beq    30$
         bis    #10000,@#174510        ; txi
;
; check for command from host
;
30$:
         jsr    pc,pcsrsrv             ; check pcsr register for command from host
         mov    @#174512,r0            ; get status from register
         bic    #177760,r0             ;
         tst    r0                     ; 0 - reset, which is not ok, but the host should act on it, not us
         bne    32$
         xascil <pcsr in reset state>
         jmp    10$                    ; yes - jump
32$:
         cmp    #2,r0                  ; 2 - ready ie ok, but not running as in not yet had start command
         bne    33$
         jmp    10$                    ; yes - jump
33$:
         cmp    #3,r0                  ; 3 - running
         bne    34$
         jmp    10$                    ; yes - jump
34$:
         xasciz <pcsr1 value wrong : >
         xwhx   174510,10
         xascil
         jmp    10$                    ; FIXME, come up with something slightly more sensible
;
; pcsrsrv - service commands issued through the pcsr registers
;
pcsrsrv:
         mov    @#174510,r1            ; #20 bit flags if a new command is in the register
;
; check if the reset bit is set in pcsr0
;
         bit    #40,r1                 ; rset bit set?
         beq    psv100                 ; no
         clrb   @#174510               ; reset rset bit - only a byte write to the low byte does this :-)
         xascil <reset by bit 40>
         jmp    t49                    ; not a reboot, but fairly close
;
; check if the #20 bit is set - this is a bit in an unused bit field of the original deuna, that xu uses to detect that pcsr0 was written into
;
psv100:
         bit    #20,r1                 ; cmd written bit set?
         bne    psv110                 ; yes
         jmp    psv900                 ; no
psv110:
         clrb   @#174510               ; reset flag bit - only a byte write to the low byte does this :-)
         bic    #177760,r1             ; mask off p0cmd bit field from pcsr0
         mov    r1,p0cmd               ; store it
         asl    r1
         add    #ptab,r1               ; add code to base of jump table
         mov    (r1),r1
         jsr    pc,(r1)                ; call the service routine
psv900:
         rts pc                        ; done
;
; nop : the real nop, command code 0
;
crnop:
         xasciz <pcsr0 noop : >
         xwhx   174510,2
         xascil
         ; ? manual says no-op, and dni bit not set
         bis    #4000,@#174510
         rts    pc
;
; nop : other command codes
;
conop:
         xasciz <pcsr0 noopx: >
         xwhx   174510,2
         xascil
         bis    #4000,@#174510
         rts    pc

;
; cmd 1
;
c0001:
;         xasciz <pcsr0 cmd1 get pcbb : >
;         xwhx   174510,10
;         xascil
         mov    @#174514,pcbbl
         mov    @#174516,pcbbh
         bis    #4000,@#174510            ; dni
         rts    pc
;
; cmd 2
;
c0010:                                 ; get cmd
;         xasciz <pcsr0 cmd2 get cmd: >
;         xwhx   174510,10
;         xascil

         mov    @#174514,10$
         mov    @#174516,11$
         jsr    pc,xubm
10$:     .word  0
11$:     .word  0
         .word  pcbb
         .word  10
         xasciz <pcbb  cmd2 : >
         xwhx   pcbb,10
         xascil
         movb   pcbb,r0
         cmpb   #26,r0
         blt    90$
         asl    r0
         add    #fctbl,r0
         mov    (r0),r0
         jsr    pc,(r0)
90$:
         rts    pc
;
; cmd 3 - self-test
;
c0011:                                 ; self-test
         bis    #4000,@#174510            ; dni
         rts    pc
;
; cmd 4 - start
;
c0100:                                 ; start
         xasciz <pcsr0 START : >
         xwhx   174510,10
         xascil
         mov    #3,@#174512            ; set state to running, clear error bits if any
         tst    running
         bne    90$                    ; was already running, skip resetting rings to start
         mov    #1,running             ; set state
;
         mov    tdrbh,xcurrh              ; clear xcurr - manual 4-9
         mov    tdrbl,xcurrl
;
         mov    rdrbh,rcurrh              ; clear rcurr - manual 4-9
         mov    rdrbl,rcurrl
;
         bis    #4000,@#174510         ; dni
90$:
         rts    pc
;
; cmd 5 - boot
;
c0101:                                 ; boot
         bis    #4000,@#174510         ; dni
         rts    pc
;
; cmd 8 - polling demand
;
c1000:                                 ; pdmd
;         xasciz <pcsr0 PDMD : >
;         xwhx   174510,10
;         xascil
;         jsr    pc,xmitpl              ; poll xmit ring
;         tst    xmitdw
;         beq    10$
;         bis    #10000,@#174510        ; txi --- FIXME, might not even be needed to set txi
;         jsr pc,waitabit
         mov    #50., pdmdct
10$:
         bis    #4000,@#174510         ; dni
         rts    pc
;
; cmd 15 : stop
;
c1111:                                 ; stop
         xasciz <pcsr0 STOP : >
         xwhx   174510,10
         xascil
         clr    running                ; set state
         mov    #2,@#174512            ; set state
         bis    #4000,@#174510         ; dni
         rts    pc
;
; command branch table
;
ptab:
         .word  crnop                     ; 0
         .word  c0001                     ; 1
         .word  c0010                     ; 2
         .word  c0011                     ; 3
         .word  c0100                     ; 4
         .word  c0101                     ; 5
         .word  conop                     ; 6
         .word  conop                     ; 7
         .word  c1000                     ; 10
         .word  conop                     ; 11
         .word  conop                     ; 12
         .word  conop                     ; 13
         .word  conop                     ; 14
         .word  conop                     ; 15
         .word  conop                     ; 16
         .word  c1111                     ; 17
;
; function branch table
;
fctbl:   .word  fc0
         .word  fc1
         .word  fc2
         .word  fc3
         .word  fc4
         .word  fc5
         .word  fc6
         .word  fc7
         .word  fc10
         .word  fc11
         .word  fc12
         .word  fc13
         .word  fc14
         .word  fc15
         .word  fc16
         .word  fc17
         .word  fc20
         .word  fc21
         .word  fc22
         .word  fc23
         .word  fc24
         .word  fc25
         .word  fc26
         .word  fc27
;
; fc0 - no-op
;
fc0:
         xascil <fc0 - noop>
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc1
;
fc1:
         xasciz <fc1 - load and start>
         bis    #40000,@#174510           ; pcei - this function is not implemented
         rts    pc
;
; fc2
;
fc2:
         xasciz <fc2 - read default physical address >
         jsr    pc,getpcbb
;
; the bia is in crazy-chip format
;
         xbhx   dbia+4,1
         xasciz <:>
         xbhx   dbia+5,1
         xasciz <:>
         xbhx   dbia+2,1
         xasciz <:>
         xbhx   dbia+3,1
         xasciz <:>
         xbhx   dbia+0,1
         xasciz <:>
         xbhx   dbia+1,1
         xascnl

         movb   dbia+4,pcbb+2
         movb   dbia+5,pcbb+3
         movb   dbia+2,pcbb+4
         movb   dbia+3,pcbb+5
         movb   dbia+0,pcbb+6
         movb   dbia+1,pcbb+7

         jsr    pc,putpcbb
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc3
;
fc3:
         xascil <fc3 - no op function>
         bis    #4000,@#174510            ; dni, ach welja
         rts    pc
;
; fc4
;
fc4:
         xasciz <fc4 - read physical address >
         jsr    pc,getpcbb
         movb   dlaa+0,pcbb+2
         movb   dlaa+1,pcbb+3
         movb   dlaa+2,pcbb+4
         movb   dlaa+3,pcbb+5
         movb   dlaa+4,pcbb+6
         movb   dlaa+5,pcbb+7
         xbhx   pcbb+2,6
         xascil
         jsr    pc,putpcbb
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc5
;
fc5:
         xasciz <fc5 - write physical address >
         jsr    pc,getpcbb
         movb   pcbb+2,dlaa+0
         movb   pcbb+3,dlaa+1
         movb   pcbb+4,dlaa+2
         movb   pcbb+5,dlaa+3
         movb   pcbb+6,dlaa+4
         movb   pcbb+7,dlaa+5
         xbhx   dlaa,6
         xascil
         jsr    pc,setlaa
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc6
;
fc6:
         xascil <fc6 - read multicast address list>
         jsr    pc,getpcbb
         movb   pcbb+5,r0
         cmp    #12,r0
         blt    90$
         mov    r0,mltreq
         tst    r0
         beq    80$
         jsr    pc,putmlt
80$:
         bis    #4000,@#174510            ; dni
         rts    pc
90$:
         bis    #44000,@#174510           ; pcei - error in req
         rts    pc
;
; fc7
;
fc7:
         xasciz <fc7 - write multicast address list >             ; FIXME, incomplete - the multicast list is ignored, only the mcen bit is set in the chip to match whether or not the list contains any entries at all             ; FIXME, incomplete
         jsr    pc,getpcbb
         movb   pcbb+5,r0
         mov    r0,mltlen
         tst    r0
         bne    20$
; FIXME         xubl   cmcen,40
         xasciz <clear>
         br     80$
20$:
         cmp    #12,r0
         blt    90$
;         xubl   smcen,40
         jsr    pc,getmlt
         xwhx   mltlen,2
         xascil
         xasciz <fc7        : >
         xbhx   mltlist,14
         xascil
         xasciz <fc7        : >
         xbhx   mltlist+14,14
         xascil
         xasciz <fc7        : >
         xbhx   mltlist+30,14
         xascil
         xasciz <fc7        : >
         xbhx   mltlist+44,14
         xascil
         xasciz <fc7        : >
         xbhx   mltlist+60,14
;         xascil
;         xasciz <fc7        : >
;         xbhx   mltlist+74,14
80$:
         xascil
         bis    #4000,@#174510            ; dni
         rts    pc
90$:
         bis    #44000,@#174510           ; pcei - error in req
         rts    pc
;
; fc10
;
fc10:
         xascil <fc10 - read ring format >
         jsr    pc,getpcbb
;
         mov    tdrbl,udbb
         mov    tdrbh,udbb+2
         movb   telen,udbb+3
         mov    trlen,udbb+4
         mov    rdrbl,udbb+6
         mov    rdrbh,udbb+10
         movb   relen,udbb+11
         mov    rrlen,udbb+12
;
         xwhx   udbb,14
         xascil
;
         mov    #14,udbblen
         jsr    pc,putudbb
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc11
;
fc11:
         xasciz <fc11 - write ring format >
         jsr    pc,getpcbb
;
         mov    #14,udbblen
         jsr    pc,getudbb
         xwhx   udbb,14
         xascil
;
         mov    udbb,tdrbl
         bic    #1,tdrbl
         mov    udbb+2,tdrbh
         bic    #177774,tdrbh
         movb   udbb+3,r0
         mov    r0,telen
         mov    udbb+4,trlen
         mov    udbb+6,rdrbl
         bic    #1,rdrbl
         mov    udbb+10,rdrbh
         bic    #177774,rdrbh
         movb   udbb+11,r0
         mov    r0,relen
         mov    udbb+12,rrlen
         bis    #4000,@#174510            ; dni
;
         mov    tdrbh,xcurrh              ; clear xcurr
         mov    tdrbl,xcurrl
;
         mov    rdrbh,rcurrh              ; clear rcurr
         mov    rdrbl,rcurrl
;
; setup pointers to last buffer
;
         mov    tdrbh,tdrmxh
         mov    tdrbl,tdrmxl

         mov    trlen,r0
         dec    r0
10$:
         add    telen,tdrmxl
         adc    tdrmxh
         add    telen,tdrmxl
         adc    tdrmxh
         dec    r0
         bne    10$

         mov    rdrbh,rdrmxh
         mov    rdrbl,rdrmxl

         mov    rrlen,r0
         dec    r0
20$:
         add    relen,rdrmxl
         adc    rdrmxh
         add    relen,rdrmxl
         adc    rdrmxh
         dec    r0
         bne    20$

         rts    pc
;
; fc12
;
fc12:
         xascil <fc12 - read counters>
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc13
;
fc13:
         xascil <fc13 - read and clear counters>
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc14
;
fc14:
         xasciz <fc14 - read mode bits >
         xwhx   modebits,2
         xascil
         jsr    pc,getpcbb
         mov    modebits,pcbb+2
         jsr    pc,putpcbb
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc15
;
fc15:
         xasciz <fc15 - write mode bits >
         xwhx   modebits,2
         xasciz ^/ -> /
         jsr    pc,getpcbb
         mov    pcbb+2,modebits
         xwhx   modebits,2
         xascil
;
         jsr    pc,setmodebits
;
         bis    #4000,@#174510            ; dni
         rts    pc
;
; fc16
;
fc16:
         xascil <fc16>
         rts    pc
;
; fc17
;
fc17:
         xascil <fc17>
         rts    pc
;
; fc20
;
fc20:
         xascil <fc20 - dump internal memory>
         bis    #44000,@#174510           ; pcei - this function is not implemented
         rts    pc
;
; fc21
;
fc21:
         xascil <fc21 - load internal memory>
         bis    #44000,@#174510           ; pcei - this function is not implemented
         rts    pc
;
; fc22
;
fc22:
         xascil <fc22>
         rts    pc
;
; fc23
;
fc23:
         xascil <fc23>
         rts    pc
;
; fc24
;
fc24:
         xascil <fc24>
         rts    pc
;
; fc25
;
fc25:
         xascil <fc25>
         rts    pc
;
; fc26
;
fc26:
         xascil <fc26>
         rts    pc
;
; fc27
;
fc27:
         xascil <fc27>
         rts    pc
;
; xmitpl : poll xmit ring for entries with own set
;
xmitpl:
         clr    xmitdw
         tst    tfpllh
         beq    xpl010
;         xascil <xmitbuf occupied>
         jmp    xpl990
;         tst    running
;         bne    xpl010
;         jmp    xpl990
xpl010:
         tst    xcurrl
         bne    xpl020
         tst    xcurrh
         bne    xpl020
         jmp    xpl990
xpl020:
         mov    r0,-(sp)
;
;         xasciz <xmit poll  : >
;         xwhx   xcurrh,2
;         xwhx   xcurrl,2
;         xascil
;
         mov    xcurrl,xolddl
         mov    xcurrh,xolddh
         clr    xplrun
;
xpl200:
         jsr    pc,getxcnh                        ; get xcurr and next header

         bit    #100000,xdre+4                   ; own bit set?
         bne    xpl210
;         xascil <not own, end>
         br     xpl700                           ; not set - check next buffer

xpl210:
;         xasciz <xmitpl ent : >
;         xwhx   xcurrh,2
;         xwhx   xcurrl,2
;         xasciz < >
;         xwhx   xdre,10

         tst    xplrun
         beq    xpl220                           ; not continuation
;         xasciz <cont >
         br     xpl320

xpl220:
         bit    #1000,xdre+4                     ; stp bit set?
         bne    xpl300                           ; yes
;         xascil <skip >
         br     xpl340                           ; own, but not stp in the first message - skip/rel

xpl300:
;         xasciz <start >
         mov    #1,xplrun
         jsr    pc,xmitst
;
; 320 - if we get here, we have either the start bit in this buffer, or it is a chained buffer and we already saw start
;
xpl320:
         bit    #400,xdre+4                      ; enp bit set?
         beq    xpl330                           ; no
         clr    xplrun
;         xasciz <end >

xpl330:
;         xascil
         jsr    pc,xmitld
         bit    #400,xdre+4                      ; enp bit set?
         beq    xpl340                           ; no
         jsr    pc,xmitxx                        ; end frame - and run, this version can only push out one frame, the spi needs to run next
         jsr    pc,xmitrb
         mov    xnextl,xcurrl
         mov    xnexth,xcurrh
         br     xpl900
xpl340:
         jsr    pc,xmitrb
xpl350:
;         xasciz <xmitpl rel : >
;         xwhx   xcurrh,2
;         xwhx   xcurrl,2
;         xasciz < >
;         xwhx   xdre,10
;         xascil
;
; advance to next entry and loop back, if all entries have not been done yet
;
xpl700:
         cmp    xnextl,xolddl
         bne    xpl710
         cmp    xnexth,xolddh
         bne    xpl710
         mov    xnextl,xcurrl
         mov    xnexth,xcurrh
         br     xpl900                    ; looped round, end of run
xpl710:
         mov    xnextl,xcurrl
         mov    xnexth,xcurrh
         jmp    xpl200
;
; exit
;
xpl900:
         mov    (sp)+,r0
xpl990:
         rts    pc
;
; xmitst: do starting things re transmission, amongst others to the chip
;
xmitst:
;
; clear xmitlen
;
         clr    xmitlen
         rts    pc
;
;
; xmitxx: do ending things re transmission, including causing the chip to transmit
;
xmitxx:
         tst    xmitmch
         beq    10$
         bis    #20000,xdre+4
10$:
         movb   xmitlen+1,tfpllh
         movb   xmitlen,tfplll
         rts    pc
;
; xmitld: load bytes from current buffer
;
xmitld:
         mov    r0,-(sp)
         mov    r1,-(sp)
         mov    r2,-(sp)
         mov    r3,-(sp)
         mov    r4,-(sp)
         mov    r5,-(sp)

         mov    xdre+0,r3                        ; load slen into r3
         mov    xdre+2,r1                        ; load segb
         bic    #1,r1                            ; clean segb l      ; FIXME, we're disregarding byte alignment here
         mov    xdre+4,r2                        ; load segb h
         bic    #177774,r2                       ; clean segb h

10$:
         mov    r3,r0                            ; copy remainder of slen
         cmp    #100,r3                          ; is the actual length left > 100
         bge    20$                              ; no
         mov    #100,r0                          ; set length for this run
20$:
;         xasciz <xmitld buf : >
;         mov    r2,buf
;         mov    r1,buf+2
;         xwhx   buf,4
         mov    r0,r4
         bit    #1,r4
         bne    22$
;         xascil
         br     23$
22$:
;         xascil <!>
         inc    r4                                ; make length an even number
23$:
;         xasciz <xubm       : >

;         mov    r2,workw
;         xwhx   workw,2
;         mov    r1,workw
;         xwhx   workw,2
;         xasciz < >
;         mov    r4,workw
;         xwhx   workw,2
;         xasciz < >
;         mov    xmitlen,workw
;         xwhx   workw,2
;         xasciz < >
;         mov    xmitlen,workw
;         add    #tfbufp,workw
;         xwhx   workw,2
;         xascil

;
; setup xubm for transfer from main system core to our buffer - length limited by logic above to 16 bytes
;
         mov    xmitlen,r5
         add    #tfbufp,r5
         mov    r5,@#177104
         mov    r1,@#177100
         mov    r2,@#177102
         movb   #0,@#177107
         movb   r4,@#177106
;
         tst    xmitlen                          ; check if this is the first part of the frame? then we need to set the mac address into the buffer
         bne    40$
;
; set mch bit for transmit ring entry
;
         clr    xmitmch
         cmpb   dlaa+0,tfbufp
         bne    25$
         cmpb   dlaa+1,tfbufp+1
         bne    25$
         cmpb   dlaa+2,tfbufp+2
         bne    25$
         cmpb   dlaa+3,tfbufp+3
         bne    25$
         cmpb   dlaa+4,tfbufp+4
         bne    25$
         cmpb   dlaa+5,tfbufp+5
         bne    25$
         mov    #1,xmitmch
;
; set our own address into the frame
;
25$:
         movb   dlaa+0,tfbufp+6
         movb   dlaa+1,tfbufp+7
         movb   dlaa+2,tfbufp+10
         movb   dlaa+3,tfbufp+11
         movb   dlaa+4,tfbufp+12
         movb   dlaa+5,tfbufp+13

40$:
         add    r0,xmitlen
         add    r0,r1                            ; add length of run to low
         adc    r2                               ; carry to high

         cmp    #100,r3
         bge    50$
         sub    #100,r3
         jmp    10$
50$:
         mov    (sp)+,r5
         mov    (sp)+,r4
         mov    (sp)+,r3
         mov    (sp)+,r2
         mov    (sp)+,r1
         mov    (sp)+,r0
         rts    pc
;
; xmitrb: release current buffer from xmit ring
;
xmitrb:
         bit    #400,xdre+4                      ; enp bit set?
         bne    30$                              ; yes
         bit    #100000,xdre+14                  ; own bit set in next buffer?
         bne    30$                              ; yes
;
; not end, and the next buffer is not owned. Must release the buffer and set error codes
;
         bis    #40000,xdre+4                   ; err summary bit
         bis    #100000,xdre+6                  ; set bufl
;
; reset own and write back
;
30$:
         bic    #100000,xdre+4                  ; clear own
         jsr    pc,putxdre                      ; write back
         rts    pc
;
; pktin: deal with packets incoming on the esp32
;
pktin:
         mov    r0,-(sp)
         mov    r1,-(sp)
         mov    r2,-(sp)
         mov    r3,-(sp)
         mov    r4,-(sp)
         mov    r5,-(sp)
         clr    recvdw                 ; clear flag, did not do any work yet
;
;
;
;         xascil <pktin>
;
; check if there is a free buffer on the receive ring. If there isn't, skip
;
         tst    rcurrl                 ; ring pointer valid?
         bne    10$                    ; yes
         tst    rcurrh                 ; ring pointer valid?
         bne    10$                    ; yes
         jmp    90$                    ; no - can't even check buffer space yet
;
; check if there is a buffer free
;
10$:
         jsr    pc,getrdre             ; might be current, but refresh just to be sure
         bit    #100000,rdre+4         ; own?
         beq    80$                    ; not own - skip pktin
;
; read frame length
;
         movb   rfpllh,flen+1
         movb   rfplll,flen
;         xasciz <pktin frame length : >
;         xwhx   flen,1
;         xascnl
         cmp     flen,#maxpay
         ble     20$
         xasciz <pktin frame length : >
         xwhx   flen,1
         xascil < over max payload>
         br      90$
;
; process frame data
;
20$:
         tst    flen
         beq    30$
         jsr    pc,getfr
         br     90$
30$:
         xascil <pktin for zero length frame>
         br     90$
;
;
;
80$:
         xascil <pktin: rcurr not own>
;
; done, exit
;
90$:
         mov    (sp)+,r5
         mov    (sp)+,r4
         mov    (sp)+,r3
         mov    (sp)+,r2
         mov    (sp)+,r1
         mov    (sp)+,r0
         rts pc
;
; getfr: move a frame from the receive buffer here onto the receive ring buffer in the main cpu memory
;
getfr:
         mov    r0,-(sp)
         mov    r1,-(sp)
         mov    r2,-(sp)
         mov    r3,-(sp)
         mov    r4,-(sp)
         mov    r5,-(sp)
;         xascil <getfr>

         tst    rcurrl
         bne    2$
         tst    rcurrh
         bne    2$
         jmp    95$
2$:
         mov    flen,r3                ; r3 gets remaining frame length
         mov    #rfbufp,r1             ; r1 gets pointer in payload
         clr    mlen
         jsr    pc,getrdre             ; might be current, but refresh just to be sure
         mov    rdre+2,r2              ; segbl into r2
         mov    rdre+4,r4              ; segbh into r4
         bic    #177774,r4             ; clean segbh
         mov    rdre,r5                ; slen into r5
         clr    rdre+6                 ; start clean      -- FIXME, this is before I checked own, is this ok?
         bit    #100000,rdre+4         ; own?
         beq    5$                     ; current buffer is not own
         bis    #1000,rdre+4           ; set stp
         br     10$
5$:
         bis    #2000,@#174510         ; rcbi
         jmp    95$                    ; done here!

10$:
         mov    r3,r0
         cmp    #100,r3                ; is the actual length left > 100
         bge    20$                    ; no
         mov    #100,r0                ; set length for this run
20$:
         cmp    r5,r0
         bge    22$
         mov    r5,r0
22$:
         bit    #1,r0                  ; uneven number of bytes?
         beq    30$                    ; no
         inc    r0                     ; round up to the next word
30$:
         mov    r2,@#177100            ; dest low word addr
         mov    r4,@#177102            ; dest high word addr
         mov    r1,@#177104            ; src addr
         movb   #1,@#177107            ; direction - to xu busmaster
         tst    r0
         beq    40$
         movb   r0,@#177106
40$:
;
;
;
         add    r0,r2                  ; add length of run to low address
         adc    r4                     ; add carry to high address
         add    r0,r1                  ; add length of run to payload buffer pointer
         sub    r0,r5                  ; subtract length of run from bytes left to do in segment
         add    r0,mlen                ; add current message length
         sub    r0,r3                  ; subtract run length from leftover frame length
         cmp    #0,r3                  ; finished frame?
         blt    50$                    ; no
         jmp    90$

50$:
         cmp    r5,#0                  ; buffer filled?
         bgt    60$

         xascil <BAZINGA!!!!!>
         tst    drdc                   ; can we do data chaining?
         beq    52$                    ; yes, go on
         add    mlen,rdre+6            ; set message length - leave other bits in there intact, given that we started out at zero...
         bis    #100000,rdre+6         ; set bufl
         bis    #40000,rdre+4          ; set errs
         br     90$
52$:

         bit    #100000,rdre+14        ; do we own the next buffer?
         bne    53$                    ; yes
         add    mlen,rdre+6            ; set message length - leave other bits in there intact, given that we started out at zero...
         bis    #100000,rdre+6         ; set bufl
         bis    #40000,rdre+4          ; set errs
         br     90$

53$:
         bic    #100000,rdre+4         ; clear own
         jsr    pc,putrdre                      ; write back
         mov    rnexth,rcurrh          ; next buffer
         mov    rnextl,rcurrl
         jsr    pc,getrdre             ; might be current, but refresh just to be sure
         mov    rdre+2,r2              ; segbl into r2
         mov    rdre+4,r4              ; segbh into r4
         bic    #177774,r4             ; clean segbh
         mov    rdre,r5                ; slen into r5
         clr    rdre+6                 ; start clean
         jmp    10$                    ; current buffer is own - we're in business
60$:
         jmp    10$
;
;
;
90$:
;         xascil <getfr end>
         bit    #100000,rdre+4
         beq    95$                    ; not own
         bis    #400,rdre+4            ; set enp
         bic    #100000,rdre+4         ; clear own
         bit    #100000,rdre+6         ; bufl already set?
         bne    91$                    ; yes, skip setting mlen
         add    mlen,rdre+6            ; set message length - leave other bits in there intact, given that we started out at zero...
91$:
         tst    drdc
         beq    92$
         bis    #20000,rdre+6          ; set nchn
92$:
         jsr    pc,putrdre                      ; write back
         mov    rnexth,rcurrh
         mov    rnextl,rcurrl
         jsr    pc,getrdre
95$:
         mov    (sp)+,r5
         mov    (sp)+,r4
         mov    (sp)+,r3
         mov    (sp)+,r2
         mov    (sp)+,r1
         mov    (sp)+,r0
99$:
         rts    pc
;
; the mac address that we use - currently this can only be the bia
;
         .even
dbia:    .word 0,0,0

;
; setlaa : set the mac address to use
;
setlaa:
;         -- FIXME can't do that. yet?
         rts    pc
         .even
dlaa:    .word 0,0,0
         .even
;
; xubl stub routine
;
xubl:
         mov r5,-(sp)
         mov 2(sp),r5
         add #10,2(sp)
;         mov 0(r5),@#177000
;         mov 4(r5),@#177004
;         mov 6(r5),@#177006
;         mov 2(r5),@#177002
         mov (sp)+,r5
         rts pc
;
; xubm stub routine
;
xubm:
         mov r5,-(sp)
         mov 2(sp),r5
         add #10,2(sp)
         mov 0(r5),@#177100
         mov 2(r5),@#177102
         mov 4(r5),@#177104
         mov 6(r5),@#177106
         mov (sp)+,r5
         rts pc
;
; getpcbb: xubm the pcbb into our memory
;
getpcbb:
         mov    pcbbl,@#177100
         mov    pcbbh,@#177102
         mov    #pcbb,@#177104
         movb   #0,@#177107
         movb   #10,@#177106
         rts    pc
;
; putpcbb: xubm our pcbb copy into the unibus memory
;
putpcbb:
         mov    pcbbl,@#177100
         mov    pcbbh,@#177102
         mov    #pcbb,@#177104
         movb   #1,@#177107
         movb   #10,@#177106
         rts    pc
;
; getudbb: get udbb from unibus, address in pcbb must be valid and length must be set in udbblen
;
getudbb:
         mov    pcbb+2,@#177100
         mov    pcbb+4,@#177102
         mov    #udbb,@#177104
         movb   #0,@#177107
         movb   udbblen,@#177106
         rts    pc
;
; putudbb: move udbb to unibus, address in pcbb must be valid and length must be set in udbblen
;
putudbb:
         mov    pcbb+2,@#177100
         mov    pcbb+4,@#177102
         mov    #udbb,@#177104
         movb   #1,@#177107
         movb   udbblen,@#177106
         rts    pc
;
; getrdre: read receive descriptor ring entry from unibus
;
getrdre:
         mov    rcurrl,@#177100
         mov    rcurrh,@#177102
         mov    #rdre,@#177104
         movb   #0,@#177107
         movb   #10,@#177106

         cmp    rcurrl,rdrmxl             ; need to wrap?
         bne    10$
         cmp    rcurrh,rdrmxh
         bne    10$
         mov    rdrbh,rnexth              ; wrap, rnext is first buffer in ring
         mov    rdrbl,rnextl
         br     20$
10$:
         mov    rcurrl,rnextl
         mov    rcurrh,rnexth
         add    relen,rnextl
         adc    rnexth
         add    relen,rnextl                     ; words, so add twice
         adc    rnexth
20$:
         mov    rnextl,@#177100
         mov    rnexth,@#177102
         mov    #rdre+10,@#177104
         movb   #0,@#177107
         movb   #10,@#177106
         rts    pc
;
; putrdre: copy receive descriptor ring entry back onto unibus
;
putrdre:
         mov    r0,-(sp)
         mov    r1,-(sp)

;         xasciz <recvpl put : >
;         xwhx   rcurrh,2
;         xwhx   rcurrl,2
;         xasciz < >
;         xwhx   rdre,10
;         xascil

         mov    rcurrl,r0
         mov    rcurrh,r1
         add    #4,r0
         adc    r1
         mov    r0,@#177100
         mov    r1,@#177102
         mov    #rdre+4,@#177104
         movb   #1,@#177107
         movb   #4,@#177106
         mov    #1,recvdw

         mov    (sp)+,r1
         mov    (sp)+,r0
         rts    pc
;
; putxdre: copy transmit descriptor ring entry back onto unibus
;
putxdre:
         mov    r0,-(sp)
         mov    r1,-(sp)

;         xasciz <xmitpl put : >
;         xwhx   xcurrh,2
;         xwhx   xcurrl,2
;         xasciz < >
;         xwhx   xdre,10
;         xascil

         mov    xcurrl,r0
         mov    xcurrh,r1
         add    #4,r0
         adc    r1
         mov    r0,@#177100
         mov    r1,@#177102
         mov    #xdre+4,@#177104
         movb   #1,@#177107
         movb   #4,@#177106
         mov    #1,xmitdw

         mov    (sp)+,r1
         mov    (sp)+,r0
         rts    pc
;
; getxcnh: copy transmit descriptor ring entry from unibus at xcurr into xdre, find which buf is next, copy that to xdre+10
;
getxcnh:
         mov    xcurrl,@#177100
         mov    xcurrh,@#177102
         mov    #xdre,@#177104
         movb   #0,@#177107
         movb   #10,@#177106

         cmp    xcurrl,tdrmxl             ; need to wrap?
         bne    10$
         cmp    xcurrh,tdrmxh
         bne    10$
         mov    tdrbh,xnexth              ; wrap, xnext is first buffer in ring
         mov    tdrbl,xnextl
         br     20$
10$:
         mov    xcurrl,xnextl
         mov    xcurrh,xnexth
         add    telen,xnextl
         adc    xnexth
         add    telen,xnextl                     ; words, so add twice
         adc    xnexth
20$:
         mov    xnextl,@#177100
         mov    xnexth,@#177102
         mov    #xdre+10,@#177104
         movb   #0,@#177107
         movb   #10,@#177106

;         xasciz <getxcnh    : >
;         xwhx   xcurrh,2
;         xwhx   xcurrl,2
;         xasciz < >
;         xwhx   xnexth,2
;         xwhx   xnextl,2
;         xascil

         rts    pc
;
; getmlt: get udbb multicast list from unibus, address in pcbb must be valid
;
getmlt:
         mov    r0,-(sp)
         mov    mltlen,r0
         add    mltlen,r0
         add    mltlen,r0
         asl    r0
         cmp    #74,r0
         blt    90$
         mov    pcbb+2,@#177100
         mov    pcbb+4,@#177102
         mov    #mltlist,@#177104
         movb   #0,@#177107
         movb   r0,@#177106
90$:
         mov    (sp)+,r0
         rts    pc
;
; putmlt: put udbb multicast list to unibus, address in pcbb must be valid
;
putmlt:
         mov    r0,-(sp)
         cmp    mltreq,mltlen
         bgt    10$
         mov    mltlen,r0
         add    mltlen,r0
         add    mltlen,r0
         asl    r0
         br     20$
10$:
         mov    mltreq,r0
         add    mltreq,r0
         add    mltreq,r0
         asl    r0
         br     20$
20$:
         cmp    #74,r0
         blt    90$
         mov    pcbb+2,@#177100
         mov    pcbb+4,@#177102
         mov    #mltlist,@#177104
         movb   #1,@#177107
         movb   r0,@#177106
90$:
         mov    (sp)+,r0
         rts    pc
;
; set mode bits into chip
;
setmodebits:
         bit    #4,modebits
         beq    10$
;         xubl   setlpbk,40
         br     19$
10$:
;         xubl   clrlpbk,40
         br     19$
19$:
;
         bit    #100000,modebits
         beq    20$
;         xubl   snotmeen,40
         br     29$
20$:
;         xubl   cnotmeen,40
         br     29$
29$:
;
         bit    #20000,modebits
         beq    30$
         mov    #1,drdc
         br     39$
30$:
         clr    drdc
         br     39$
39$:
         rts    pc
;
; print an ascii zero terminated string, string directly follows jsr pc insn
;
xasciz:
         mov r1,-(sp)                  ; push r1
         mov 2(sp),r1                  ; set r1 to return address
10$:
         tstb @#177564                 ; output busy?
         bpl 10$                       ; yes, spin
         tstb (r1)                     ; byte zero?
         beq 20$                       ; yes, exit
         movb (r1)+,@#177566           ; move byte into transmit register
         br 10$                        ; next byte
20$:
         inc r1
         bit #1,r1                     ; check if even address
         beq 30$                       ; yes
         inc r1                        ; no - move to next byte
30$:
         mov r1,2(sp)                  ; correct stored return address
         mov (sp)+,r1                  ; pop r1
         rts pc                        ; return to corrected pc
;
; print a variable number of hex bytes, separated by space
;
xbhx:
         mov r5,-(sp)
         mov 2(sp),r5
         add #4,2(sp)
         mov r0,-(sp)
         mov r1,-(sp)
         mov r2,-(sp)
         mov 0(r5),r2
         mov 2(r5),r0
10$:
         movb (r2)+,r1
         jsr pc,bhexb
         dec r0
         tst r0
         beq 30$
20$:
         tstb @#177564                 ; output busy?
         bpl 20$                       ; yes, spin
         movb #40,@#177566             ; move byte into transmit register
         br 10$
30$:
         mov (sp)+,r2
         mov (sp)+,r1
         mov (sp)+,r0
         mov (sp)+,r5
         rts pc
;
; print a variable number of hex words, separated by space
;
xwhx:
         mov r5,-(sp)
         mov 2(sp),r5
         add #4,2(sp)
         mov r0,-(sp)
         mov r1,-(sp)
         mov r2,-(sp)
         mov 0(r5),r2
         mov 2(r5),r0
10$:
         mov (r2)+,r1                  ; load the word
         swab r1                       ; high byte first
         jsr pc,bhexb
         swab r1                       ; swap to low byte
         jsr pc,bhexb
         dec r0                        ; count in bytes, decrement twice
         tst r0                        ; but check for zero anyway - dont want 65536 words, ever
         beq 30$
         dec r0
         tst r0
         beq 30$
20$:
         tstb @#177564                 ; output busy?
         bpl 20$                       ; yes, spin
         movb #40,@#177566             ; move byte into transmit register
         br 10$
30$:
         mov (sp)+,r2
         mov (sp)+,r1
         mov (sp)+,r0
         mov (sp)+,r5
         rts pc
;
; print an ascii zero terminated string, r1 has pointer to string
;
basciz:
         mov r1,-(sp)
10$:
         tstb @#177564                 ; output busy?
         bpl 10$                       ; yes, spin
         tstb (r1)                     ; byte zero?
         beq 20$                       ; yes, exit
         movb (r1)+,@#177566           ; move byte into transmit register
         br 10$                        ; next byte
20$:
         mov (sp)+,r1
         rts pc                        ; exit
;
; print a hex byte, contained in r1 lower byte
;
bhexb:
         mov r0,-(sp)
         mov r1,-(sp)
         mov r1,r0
         asr r0
         asr r0
         asr r0
         asr r0
         bic #177760,r0
         add #hextab,r0
10$:
         tstb @#177564                 ; output busy?
         bpl 10$                       ; yes, spin
         movb (r0),@#177566            ; move byte into transmit register
         bic #177760,r1
         add #hextab,r1
20$:
         tstb @#177564                 ; output busy?
         bpl 20$                       ; yes, spin
         movb (r1),@#177566            ; move byte into transmit register
         mov (sp)+,r1
         mov (sp)+,r0
         rts pc
;
; print two hex bytes separated by space, followed by crlf. Input in bytes pointed to by r1
;
bhx2:
         mov r0,-(sp)
         mov #2,r0
         jsr pc,bhx
         mov (sp)+,r0
         rts pc
;
; print a variable number of hex bytes, separated by space, followed by crlf. Input in bytes pointed to by r1, r0 has length of buffer.
;
bhx:
         mov r1,-(sp)
         mov r2,-(sp)
         mov r1,r2
10$:
         movb (r2)+,r1
         jsr pc,bhexb
         dec r0
         tst r0
         beq 30$
20$:
         tstb @#177564                 ; output busy?
         bpl 20$                       ; yes, spin
         movb #40,@#177566             ; move byte into transmit register
         br 10$
30$:
         mov (sp)+,r2
         mov (sp)+,r1
         rts pc
;
; init - clear variables and status registers to their initial values
;
init:
         clr    running
         clr    flen
         clr    drdc
         clr    modebits

         clr    pdmdct

         clr    tdrbh
         clr    tdrbl
         clr    telen
         clr    trlen
         clr    rdrbh
         clr    rdrbl
         clr    relen
         clr    rrlen

         clr    xcurrl
         clr    xcurrh
         clr    rcurrl
         clr    rcurrh

         mov    #0,@#174510               ; pcsr0 - clear any pending interrupts
         mov    #0,@#174512               ; pcsr1 - state=reset
         mov    #0,@#174514               ; pcsr2
         mov    #0,@#174516               ; pcsr3

         rts    pc
;
; waitabit - wait loop for 65535 cycles
;
waitabit:
         mov r0,-(sp)
         clr r0
10$:
         inc r0
         bne 10$
         mov (sp)+,r0
         rts pc
;
; dog - timer service routine, watchdog timer
;
dog:
         inc dogtick
         cmp #600.,dogtick             ; assuming 60hz clock, 10 seconds
         bgt 90$
         xascil <dog barks>
         jmp t49
90$:
         rti
;
; data
;
hextab:  .ascii /0123456789abcdef/

         .even
running: .word 0                       ; if nonzero, then recv/xmit is active
flen:    .word 0                       ; frame length in the encx24j600 received frame header
p0cmd:   .word 0                       ; masked off value of the pcsr0
pdmdct:  .word 0                       ; poll demand count
;
dogtick: .word 0                       ; watchdog timer value
;
modebits:.word 0                       ; fc14/15 format mode bits word
;
tdrbh:   .word 0
tdrbl:   .word 0
telen:   .word 0
trlen:   .word 0
tdrmxh:  .word 0
tdrmxl:  .word 0

rdrbh:   .word 0
rdrbl:   .word 0
relen:   .word 0
rrlen:   .word 0
rdrmxh:  .word 0
rdrmxl:  .word 0
;
xplrun:  .word 0                       ; xmitpl status, between start and end
;
rcurrh:  .word 0
rcurrl:  .word 0
;
rnexth:  .word 0
rnextl:  .word 0
;
xcurrh:  .word 0                       ; xmit current address, h
xcurrl:  .word 0                       ; xmit current address, l
;
xnexth:  .word 0                       ; xmit next address, h
xnextl:  .word 0                       ; xmit next address, l
;
xolddh:  .word 0                       ; xmit old address, h
xolddl:  .word 0                       ; xmit old address, l
;
xmitlen: .word 0                       ; current frame length
;
xmitmch: .word 0                       ; xmit frame should have match bit set in enp buffer
;
mlen:    .word 0                       ; received message length placed in buffer
;
drdc:    .word 0                       ; disable recv data chaining
;
xdre:    .word 0,0,0,0,0,0,0,0         ; work area, transmit descriptor (curr+next)
;
rdre:    .word 0,0,0,0,0,0,0,0         ; work area, receive descriptor (curr+next)
;
recvdw:  .word 0                       ; flag receive did work
xmitdw:  .word 0                       ; flag transmit did work
;
pcbbl:   .word 0
pcbbh:   .word 0
pcbb:    .word 0,0,0,0
;
mltreq:  .word 0
mltlen:  .word 0
mltlist: .blkw 36
;
udbblen: .word 0
udbb:    .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0             ; 32 words
         .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
;
pktcnt:  .byte 0
         .even
workw:   .word 0
         .even
buf:     .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
;
; receive buffer
;
         .even
rfbuf:
rfmgk1:  .byte 0                       ; magic header should be 0xaa
rfmgk2:  .byte 0                       ; magic header should be 0x55
rffrq:   .byte 0                       ; 8-bit circular frame counter
rfqf:    .byte 0                       ; unsigned number of frames queued in the esp32 receive queue
rfpllh:  .byte 0                       ; payload length high byte
rfplll:  .byte 0                       ; payload length low byte
rfmac:   .blkw 3                       ; mac address
rfbufp:  .blkb maxpay
;
; transmit buffer
;
         .even
tfbuf:
tfmgk:   .word 0                       ; magic header should be 0xa0a0
tffrq:   .byte 0                       ; 8-bit circular frame counter
tfqf:    .byte 0                       ; mbz
tfpllh:  .byte 0                       ; payload length high byte
tfplll:  .byte 0                       ; payload length low byte
tfmac:   .blkw 3                       ; mac address
tfbufp:  .blkb maxpay

endmrk:  .byte 377,377,377,377,377,377,377,377
